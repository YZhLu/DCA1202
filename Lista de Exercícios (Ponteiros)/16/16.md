16_ Procure na internet mecanismos que 
possibilitem medir tempos de execucÌ§aÌƒo 
de rotinas computacionais. Geralmente, 
estas medidas saÌƒo realizadas com 
o auxiÌlio de funcÌ§oÌƒes em C que leÌ‚em 
a hora no sistema (sistemas Unix e 
Windows geralmente usam funcÌ§oÌƒes diferentes). 
Utilizando os conhecimentos que 
voceÌ‚ obteve com sua pesquisa, 
mecÌ§a os tempos de execucÌ§aÌƒo das 
implementacÌ§oÌƒes que voceÌ‚ criou para os 
dois problemas de ordenacÌ§aÌƒo anteriores e 
compare os resultados obtidos.

Resposta:

https://github.com/YZhLu/DCA1202/blob/main/Lista%20de%20Exerc%C3%ADcios%20(Ponteiros)/16/16.c

```
|>>>>>>______________________________________________<<<<<<|

 Â»Tempo de execuÃ§Ã£o de 14.c 'qsort()': 0.004906 seconds

 Â»Tempo de execuÃ§Ã£o de 15.c 'my_qsort()': 0.826519 seconds

 Â»Â»Tempo total: 0.840853 seconds

|<<<<<<______________________________________________>>>>>>|
```

Podemos perceber que para uma Ãºnica amostra, executada em um `vetor` de `10000` itens, a funÃ§Ã£o `qsort()`, presente na em `<stdlib.h>` foi significativamente mais eficiente que a funÃ§Ã£o `my_qsort()` construida por nÃ³s.  ğŸ˜¢ğŸ˜ğŸ’”ğŸ˜­ğŸ¥ºğŸ˜£ğŸ˜µâ€ğŸ’«
